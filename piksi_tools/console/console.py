#!/usr/bin/env python
# Copyright (C) 2011-2014 Swift Navigation Inc.
# Contact: Fergus Noble <fergus@swift-nav.com>
#
# This source is subject to the license found in the file 'LICENSE' which must
# be be distributed together with this source. All other rights reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
# EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

import os
import piksi_tools.serial_link as s
import sbp.client as sbpc
import signal
import sys

import math
import os
import numpy as np
import datetime
import time


from piksi_tools.serial_link import swriter, get_uuid, DEFAULT_BASE
from piksi_tools.version import VERSION as CONSOLE_VERSION
from piksi_tools.heartbeat import Heartbeat
from sbp.client.drivers.pyftdi_driver import PyFTDIDriver
from sbp.client.drivers.pyserial_driver import PySerialDriver
from sbp.client.drivers.network_drivers import TCPDriver
from sbp.ext_events import *
from sbp.logging import *
from sbp.piksi import SBP_MSG_RESET, MsgReset
from sbp.piksi import *
from sbp.navigation import *
from sbp.system import SBP_MSG_HEARTBEAT
from sbp.client import Forwarder


# Shut chaco up for now
import warnings
warnings.simplefilter(action = "ignore", category = FutureWarning)

def get_args():
  """
  Get and parse arguments.
  """
  import argparse
  parser = argparse.ArgumentParser(description='Swift Nav Console.')
  parser.add_argument('-p', '--port', nargs=1, default=[None],
                      help='specify the port to use.')
  parser.add_argument('-b', '--baud', nargs=1, default=[s.SERIAL_BAUD],
                      help='specify the baud rate to use.')
  parser.add_argument("-v", "--verbose",
                      help="print extra debugging information.",
                      action="store_true")
  parser.add_argument("-l", "--log",
                      action="store_true",
                      help="serialize SBP messages to log file.")
  parser.add_argument("-o", "--log-filename",
                      default=[s.logfilename()], nargs=1,
                      help="file to log output to. If a directory is provided the "
                           "filename is autogenerated.")
  parser.add_argument("-i", "--initloglevel",
                      default=[None], nargs=1,
                      help="Set log level filter.")
  parser.add_argument("-r", "--reset",
                      action="store_true",
                      help="reset device after connection.")
  parser.add_argument("-u", "--update",
                      help="don't prompt about firmware/console updates.",
                      action="store_false")
  parser.add_argument("-f", "--ftdi",
                      help="use pylibftdi instead of pyserial.",
                      action="store_true")
  parser.add_argument("--file",
                      help="Read with a filedriver rather than pyserial.",
                      action="store_true")
  parser.add_argument('-t', '--toolkit', nargs=1, default=[None],
                      help="specify the TraitsUI toolkit to use, either 'wx' or 'qt4'.")
  parser.add_argument("--tcp", action="store_true", default=False,
                      help="Use a TCP connection instead of a local serial port. \
                      If TCP is selected, the port is interpreted as host:port")
  parser.add_argument('--error', action='store_true',
                      help="Do not swallow exceptions.")
  return parser.parse_args()

args = get_args()
port = args.port[0]
baud = args.baud[0]

# Toolkit
from traits.etsconfig.api import ETSConfig
if args.toolkit[0] is not None:
  ETSConfig.toolkit = args.toolkit[0]
else:
  ETSConfig.toolkit = 'qt4'

# Logging
import logging
logging.basicConfig()
from piksi_tools.console.output_list import OutputList, LogItem, str_to_log_level, \
  SYSLOG_LEVELS, DEFAULT_LOG_LEVEL_FILTER
from piksi_tools.console.utils import determine_path
from piksi_tools.console.deprecated import DeprecatedMessageHandler

# When bundled with pyInstaller, PythonLexer can't be found. The problem is
# pygments.lexers is doing some crazy magic to load up all of the available
# lexers at runtime which seems to break when frozen.
#
# The horrible workaround is to load the PythonLexer class explicitly and then
# manually insert it into the pygments.lexers module.
from pygments.lexers.agile import PythonLexer
import pygments.lexers
pygments.lexers.PythonLexer = PythonLexer
try:
  import pygments.lexers.c_cpp
except ImportError:
  pass

# These imports seem to be required to make pyinstaller work?
# (usually traitsui would load them automatically)
if ETSConfig.toolkit == 'qt4':
  import pyface.ui.qt4.resource_manager
  import pyface.ui.qt4.python_shell
from pyface.image_resource import ImageResource

basedir = determine_path()
icon = ImageResource('icon', search_path=['images', os.path.join(basedir, 'images')])

from piksi_tools.console.tracking_view import TrackingView
from piksi_tools.console.solution_view import SolutionView
from piksi_tools.console.baseline_view import BaselineView
from piksi_tools.console.observation_view import ObservationView
from piksi_tools.console.sbp_relay_view import SbpRelayView
from piksi_tools.console.system_monitor_view import SystemMonitorView
from piksi_tools.console.settings_view import SettingsView
from piksi_tools.console.update_view import UpdateView
from enable.savage.trait_defs.ui.svg_button import SVGButton


from traits.api import Str, Instance, Dict, HasTraits, Int, Button, List, Enum, Bool, File
from traitsui.api import Item, Label, View, HGroup, VGroup, VSplit, HSplit, Tabbed, \
                         InstanceEditor, EnumEditor, ShellEditor, Handler, Spring, \
                         TableEditor, UItem, Group
from traitsui.table_filter \
    import EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate, \
           EvalTableFilter
from traitsui.table_column \
    import ObjectColumn, ExpressionColumn

from traitsui.file_dialog \
    import open_file


CONSOLE_TITLE = 'Piksi Console, Version: v' + CONSOLE_VERSION


class ConsoleHandler(Handler):
  """
  Handler that updates the window title with the device serial number

  This Handler is used by Traits UI to manage making changes to the GUI in
  response to changes in the underlying class/data.
  """

  def object_device_serial_changed(self, info):
    """
    Update the window title with the device serial number.

    This is a magic method called by the handler in response to any changes in
    the `device_serial` variable in the underlying class.
    """
    if info.initialized:
      info.ui.title = CONSOLE_TITLE + ' : ' + info.object.device_serial


class SwiftConsole(HasTraits):
  """Traits-defined Swift Console.

  link : object
    Serial driver
  update : bool
    Update the firmware
  log_level_filter : str
    Syslog string, one of "ERROR", "WARNING", "INFO", "DEBUG".
  skip_settings : bool
    Don't read the device settings. Set to False when the console is reading
    from a network connection only.

  """

  link = Instance(sbpc.Handler)
  console_output = Instance(OutputList())
  python_console_env = Dict
  device_serial = Str('')
  a = Int
  b = Int
  tracking_view = Instance(TrackingView)
  solution_view = Instance(SolutionView)
  baseline_view = Instance(BaselineView)
  observation_view = Instance(ObservationView)
  networking_view = Instance(SbpRelayView)
  observation_view_base = Instance(ObservationView)
  system_monitor_view = Instance(SystemMonitorView)
  settings_view = Instance(SettingsView)
  update_view = Instance(UpdateView)
  log_level_filter = Enum(list(SYSLOG_LEVELS.itervalues()))


  """"
  mode : baseline and solution view - SPP, Fixed or Float
  num_sat : baseline and solution view - number of satellites
  port : which port is Piksi connected to
  logging_button : start or stop logging
  directory_name : location of logged files
  JSON : enable JSON logging

  """

  mode = Str('') 
  num_sats = Int(0)
  port = Str('')
  directory_name = File
  json_logging = Bool(True)
  csv_logging = Bool(False)
  is_valid_directory = Bool (True)


  csv_logging_button = SVGButton(
   toggle=True, label='CSV log', tooltip='start CSV logging', toggle_tooltip='stop CSV logging', 
   filename=os.path.join(determine_path(), 'images', 'iconic', 'pause.svg'),
   toggle_filename=os.path.join(determine_path(), 'images', 'iconic', 'play.svg'),
   orientation = 'vertical',
   width=2, height=2,
  )
  json_logging_button = SVGButton(
   toggle=True, label='JSON log', tooltip='start JSON logging', toggle_tooltip='stop JSON logging', 
   filename=os.path.join(determine_path(), 'images', 'iconic', 'pause.svg'),
   toggle_filename=os.path.join(determine_path(), 'images', 'iconic', 'play.svg'),
   orientation = 'vertical',
   width=2, height=2,
  )
  paused_button = SVGButton(
    label='', tooltip='Pause console update', toggle_tooltip='Resume console update', toggle=True,
    filename=os.path.join(determine_path(), 'images', 'iconic', 'pause.svg'),
    toggle_filename=os.path.join(determine_path(), 'images', 'iconic', 'play.svg'),
    width=8, height=8
  )
  clear_button = SVGButton(
    label='', tooltip='Clear console buffer',
    filename=os.path.join(determine_path(), 'images', 'iconic', 'x.svg'),
    width=8, height=8
  )

  view = View(
    VSplit(
      Tabbed(
        Item('tracking_view', style='custom', label='Tracking'),
        Item('solution_view', style='custom', label='Solution'),
        Item('baseline_view', style='custom', label='Baseline'),
        VSplit(
          Item('observation_view', style='custom', show_label=False),
          Item('observation_view_base', style='custom', show_label=False),
          label='Observations',
        ),
        Item('settings_view', style='custom', label='Settings'),
        Item('update_view', style='custom', label='Firmware Update'),
        Tabbed(
          Item('system_monitor_view', style='custom', label='System Monitor'),
          Item('networking_view', label='Networking', style='custom', show_label=False),
          Item(
            'python_console_env', style='custom',
            label='Python Console', editor=ShellEditor()),
          label='Advanced',
          show_labels=False
         ),
        show_labels=False
      ),
      VGroup(
        VGroup(
          HGroup(
            Spring(width=4, springy=False),
            Item('paused_button', show_label=False, padding=0, width=8, height=8),
            Item('clear_button', show_label=False, width=8, height=8),
            Item('', label='Console Log', emphasized=True),
            Item('csv_logging_button', emphasized=True, show_label=False, width=12, height=-25, padding=0),
            Item('json_logging_button', emphasized=True, show_label=False, width=12, height=-25, padding=0),
            Item('directory_name', show_label=False, springy=True, tooltip='Choose location for file logs. Default is current directory.', 
              height=-25, enabled_when='not(json_logging or csv_logging)'),
          
            #Spring(),
            UItem('log_level_filter', style='simple', padding=0, height=8, show_label=True,
                tooltip='Show log levels up to and including the selected level of severity.\nThe CONSOLE log level is always visible.'),
        ),
        
        Item(
          'console_output',
          style='custom',
          editor=InstanceEditor(),
          height=125,
          show_label=False,
          full_size=True
        ),
        ),
        HGroup(
          Spring(width=4, springy=False),
          Item('', label='PORT:', emphasized=True, tooltip='Serial Port that Piksi is connected to'),
          Item('port', show_label=False, style = 'readonly'),
          Item('', label='FIX TYPE:', emphasized = True, tooltip='Piksi Mode: SPS, Float RTK, Fixed RTK'),
          Item('mode', show_label = False, style = 'readonly'),
          Item('', label='#SATS:', emphasized=True, tooltip='Number of satellites acquired by Piksi'),
          Item('num_sats', show_label=False, style = 'readonly'),
          
        ),
      ),
    ),
    icon=icon,
    resizable=True,
    width=800,
    height=600,
    handler=ConsoleHandler(),
    title=CONSOLE_TITLE
  )

  

  def print_message_callback(self, sbp_msg, **metadata):
    try:
      encoded = sbp_msg.payload.encode('ascii', 'ignore')
      for eachline in reversed(encoded.split('\n')):
        self.console_output.write_level(eachline,
                                        str_to_log_level(eachline.split(':')[0]))
    except UnicodeDecodeError:
      print "Critical Error encoding the serial stream as ascii."

  def log_message_callback(self, sbp_msg, **metadata):
    
    try:
      encoded = sbp_msg.text.encode('ascii', 'ignore')
      for eachline in reversed(encoded.split('\n')):
        self.console_output.write_level(eachline, sbp_msg.level)
    except UnicodeDecodeError:
      print "Critical Error encoding the serial stream as ascii."

  def ext_event_callback(self, sbp_msg, **metadata):
    e = MsgExtEvent(sbp_msg)
    print 'External event: %s edge on pin %d at wn=%d, tow=%d, time qual=%s' % (
      "Rising" if (e.flags & (1<<0)) else "Falling", e.pin, e.wn, e.tow,
      "good" if (e.flags & (1<<1)) else "unknown")

  def _paused_button_fired(self):
    self.console_output.paused = not self.console_output.paused

  def _log_level_filter_changed(self):
    """
    Takes log level enum and translates into the mapped integer.
    Integer stores the current filter value inside OutputList.
    """
    self.console_output.log_level_filter = str_to_log_level(self.log_level_filter)

  def _clear_button_fired(self):
    self.console_output.clear()

  def _directory_name_changed(self):
    if os.path.isdir(self.directory_name):
      self.is_valid_directory = True
      if self.baseline_view and self.solution_view:
        self.baseline_view.directory_name_b = self.directory_name
        self.solution_view.directory_name_p = self.directory_name
        self.solution_view.directory_name_v = self.directory_name
    else:
      print "Please enter a valid directory!"
      self.is_valid_directory = False

  def update_on_heartbeat(self, sbp_msg, **metadata):
     # First initialize the state to nothing, if we can't update, it will be none
    temp_mode = "None"
    temp_num_sats = 0
    view = None
    # If we have a recent baseline update, we use the baseline info
    if time.time() - self.baseline_view.last_btime_update < 1:
      view = self.baseline_view
    # Otherwise, if we have a recent SPP update, we use the SPP
    elif time.time() - self.solution_view.last_stime_update < 1:
      view = self.solution_view
    if view:
      if view.last_soln:
        # if all is well we update state
        temp_mode = view.mode_string(view.last_soln)
        temp_num_sats = view.last_soln.n_sats
    
    self.mode = temp_mode
    self.num_sats = temp_num_sats

  def _csv_logging_button_fired(self):
    if self.is_valid_directory:
      if self.csv_logging and self.baseline_view.logging_b and self.solution_view.logging_p and self.solution_view.logging_v:
        print "Stopped CSV logging"
        self.csv_logging =  False
        self.baseline_view.logging_b = False
        self.solution_view.logging_p = False
        self.solution_view.logging_v = False

      else: 
        print "Started CSV logging"
        self.csv_logging = True
        self.baseline_view.logging_b = True
        self.solution_view.logging_p = True
        self.solution_view.logging_v = True
    else:
      print "Directory not valid"
      
  def _start_json_logging(self, override_filename=None):

      if override_filename:
        filename = override_filename
      else:
        filename = s.logfilename()
      filename = os.path.join(self.directory_name, filename)

      self.logger = s.get_logger(True, filename)
      self.forwarder = sbpc.Forwarder(self.link, self.logger)
      self.forwarder.start()


  def _stop_json_logging(self):
    fwd = self.forwarder
    fwd.stop()
    self.logger.flush()
    self.logger.close()

  def _json_logging_button_fired(self):
    if self.is_valid_directory:
      if self.first_json_press and self.json_logging:
        print "JSON Logging initiated via CMD line.  Please press button again to stop logging"
      elif self.json_logging:
        self._stop_json_logging()
        self.json_logging = False
        print "Stopped JSON logging"
      else:
        self._start_json_logging()
        self.json_logging = True
        print "Started JSON logging" 
      self.first_json_press = False
    else: 
      print "Directory not valid"


  def __init__(self, link, update, log_level_filter, skip_settings=False, error=False, 
               port=None, json_logging=False, log_filename=None):
    self.console_output = OutputList()
    self.console_output.write("Console: starting...")
    self.error = error
    sys.stdout = self.console_output
    self.port = port
    self.num_sats = 0
    self.mode = ''
    self.forwarder = None
    # if we have passed a logfile, we set our directory to it
    override_filename = None
    
    if os.path.isdir(log_filename):
      self.is_valid_directory = True
      self.directory_name = log_filename
    else:
      self.directory_name = os.getcwd()
      #if log_filename is valid:
      try:
        open(log_filename, 'w')
        override_filename = log_filename
      except IOError:
        print "Invalid file name. Using default log file name."


    print "dir name is {0}".format(self.directory_name)
    if not error:
      sys.stderr = self.console_output
    self.log_level_filter = log_level_filter
    self.console_output.log_level_filter = str_to_log_level(log_level_filter)
    try:
      self.link = link
      self.link.add_callback(self.print_message_callback, SBP_MSG_PRINT_DEP)
      self.link.add_callback(self.log_message_callback, SBP_MSG_LOG)
      self.link.add_callback(self.ext_event_callback, SBP_MSG_EXT_EVENT)
      self.link.add_callback(self.update_on_heartbeat, SBP_MSG_HEARTBEAT)
      self.dep_handler = DeprecatedMessageHandler(link)
      settings_read_finished_functions = []
      self.tracking_view = TrackingView(self.link)
      self.solution_view = SolutionView(self.link)
      self.baseline_view = BaselineView(self.link)
      self.observation_view = ObservationView(self.link, name='Rover', relay=False)
      self.observation_view_base = ObservationView(self.link, name='Base', relay=True)
      self.system_monitor_view = SystemMonitorView(self.link)
      self.update_view = UpdateView(self.link, prompt=update)
      settings_read_finished_functions.append(self.update_view.compare_versions)
      self.networking_view = SbpRelayView(self.link)
      self.json_logging = json_logging
      self.csv_logging = False
      self.first_json_press = True
      if json_logging:
        self._start_json_logging(override_filename)
        self.json_logging = True

      # Once we have received the settings, update device_serial with
      # the Piksi serial number which will be displayed in the window
      # title. This callback will also update the header route as used
      # by the networking view.
      def update_serial():
        serial_string = self.settings_view.settings['system_info']['serial_number'].value
        self.device_serial = 'PK%04d' % int(serial_string)
        if serial_string:
          self.networking_view.set_route(int(serial_string))
      settings_read_finished_functions.append(update_serial)
      self.settings_view = SettingsView(self.link,
                                        settings_read_finished_functions,
                                        skip=skip_settings)
      self.update_view.settings = self.settings_view.settings
      self.python_console_env = { 'send_message': self.link,
                                  'link': self.link, }
      self.python_console_env.update(self.tracking_view.python_console_cmds)
      self.python_console_env.update(self.solution_view.python_console_cmds)
      self.python_console_env.update(self.baseline_view.python_console_cmds)
      self.python_console_env.update(self.observation_view.python_console_cmds)
      self.python_console_env.update(self.networking_view.python_console_cmds)
      self.python_console_env.update(self.system_monitor_view.python_console_cmds)
      self.python_console_env.update(self.update_view.python_console_cmds)
      self.python_console_env.update(self.settings_view.python_console_cmds)




    except:
      import traceback
      traceback.print_exc()
      if self.error:
        sys.exit(1)

# Make sure that SIGINT (i.e. Ctrl-C from command line) actually stops the
# application event loop (otherwise Qt swallows KeyboardInterrupt exceptions)
signal.signal(signal.SIGINT, signal.SIG_DFL)

# If using a device connected to an actual port, then invoke the
# regular console dialog for port selection
class PortChooser(HasTraits):
  ports = List()
  port = Str(None)
  traits_view = View(
    VGroup(
      Label('Select Piksi device:'),
      Item('port', editor=EnumEditor(name='ports'), show_label=False),
    ),
    buttons = ['OK', 'Cancel'],
    close_result=False,
    icon = icon,
    width = 250,
    title = 'Select serial device',
  )

  def __init__(self):
    try:
      self.ports = [p for p, _, _ in s.get_ports()]
    except TypeError:
      pass

if args.tcp:
  try:
    host, port = port.split(':')
    selected_driver = TCPDriver(host, int(port))
  except:
    raise Exception('Invalid host and/or port')
else:
  if not port:
    port_chooser = PortChooser()
    is_ok = port_chooser.configure_traits()
    port = port_chooser.port
    if not port or not is_ok:
      print "No serial device selected!"
      sys.exit(1)
    else:
      print "Using serial device '%s'" % port

  selected_driver = s.get_driver(args.ftdi, port, baud, args.file)

with selected_driver as driver:
  with sbpc.Handler(sbpc.Framer(driver.read, driver.write, args.verbose)) as link:
    if args.reset:
      link(MsgReset())
    log_filter = DEFAULT_LOG_LEVEL_FILTER
    if args.initloglevel[0]:
      log_filter = args.initloglevel[0]
    SwiftConsole(link, args.update, log_filter, port=port, error=args.error, 
                 json_logging=args.log, log_filename=args.log_filename[0]).configure_traits()

# Force exit, even if threads haven't joined
try:
  os._exit(0)
except:
  pass
